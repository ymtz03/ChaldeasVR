using System.Collections.Generic;
using System.Text.RegularExpressions;

public class CubeData {

    public string[] CommentLines { get; set; } // array<str>(2)
    public int NAtoms { get; set; }
    public double[] Origin { get; set; } // array<float>(3)
    public int[] NVoxels { get; set; } // array<int>(3)
    public double[,] Axes { get; set; } // array<float>(3,3)
    public int[] AtomicNumbers { get; set; } // array<int>(natoms)
    public double[] NuclearCharges { get; set; } // array<float>(natoms)
    public double[,] AtomPositions { get; set; } // array<float>(natoms,3)
    //public double[,,,] Data { get; set; } // array<float>(nvoxels[0],[1],[2],nval)
    public List<double[,,]> Data { get; set; } // array<float>(nvoxels[0],[1],[2],nval)
    public bool ContainDsetIds { get; set; }
    public int NVal { get; set; }
    //public int[] DsetIds { get; set; } // array<int>(nval)
    public List<int> DsetIds { get; set; } // array<int>(nval)

    public CubeData(){
        CommentLines = new string[] { "This is empty CubeData,", "generated by the default constructor. :)" };
        NAtoms = 0;
        ContainDsetIds = false;
    }

    public CubeData(
        string[] commentLines,
        int nAtoms,
        double[] origin,
        int[] nVoxels,
        double[,] axes,
        int[] atomicNumbers,
        double[] nuclearCharges,
        double[,] atomPositions,
        List<double[,,]> data,
        bool containDsetIds = false,
        int nVal = 1 ,
        List<int> dsetIds = null
    ){
        CommentLines = commentLines;
        NAtoms = nAtoms;
        Origin = origin;
        NVoxels = nVoxels;
        Axes = axes;
        AtomicNumbers = atomicNumbers;
        NuclearCharges = nuclearCharges;
        AtomPositions = atomPositions;
        Data = data;
        ContainDsetIds = containDsetIds;
        NVal = nVal;
        DsetIds = dsetIds;
    }

    public void Save(string filePath){
        var fileInfo = new System.IO.FileInfo(filePath);

        using(var sw = new System.IO.StreamWriter(fileInfo.OpenWrite())){
            sw.WriteLine(CommentLines[0]);
            sw.WriteLine(CommentLines[1]);

            int sign = 1;
            if (ContainDsetIds) { sign = -1; }
            sw.Write(" {0,4:D}", sign * NAtoms);
            sw.Write(" {0,11:F6} {1,11:F6} {2,11:F6}", Origin[0], Origin[1], Origin[2]);
            if(ContainDsetIds){ sw.Write(" {0,4:D}", NVal); }
            sw.WriteLine();

            for (int iaxis = 0; iaxis < 3; ++iaxis){
                sw.Write(" {0,4:D}", NVoxels[iaxis]);
                sw.WriteLine(" {0,11:F6} {1,11:F6} {2,11:F6}", Axes[iaxis, 0], Axes[iaxis, 1], Axes[iaxis, 2]);
            }

            for (int iatom = 0; iatom < NAtoms; ++iatom){
                sw.Write(" {0,4:D}", AtomicNumbers[iatom]);
                sw.Write(" {0,11:F6}", NuclearCharges[iatom]);
                sw.WriteLine(" {0,11:F6} {1,11:F6} {2,11:F6}", 
                             AtomPositions[iatom, 0], AtomPositions[iatom, 1], AtomPositions[iatom, 2]);
            }

            if(ContainDsetIds){
                sw.Write(" {0,4:D}", NVal);
                int icolumn = 1;
                foreach(int dset_id in DsetIds){
                    if (icolumn % 10 == 0) { sw.WriteLine(); }
                    sw.Write(" {0,4:D}", dset_id);
                    ++icolumn;
                }
                sw.WriteLine();
            }

            for (int ix = 0; ix < NVoxels[0]; ++ix){
                for (int iy = 0; iy < NVoxels[1]; ++iy){
                    int icolumn = 0;
                    for (int iz = 0; iz < NVoxels[2]; ++iz){
                        for (int im = 0; im < NVal; ++im){
                            if (icolumn % 6 == 0 && icolumn > 0) { sw.WriteLine(); }
                            var val = Data[im][ix, iy, iz];
                            if (System.Math.Abs(val) < 1e-99) { val = 0; }
                            //sw.Write(" {0:E5+00}", val);
                            sw.Write(val.ToString("  0.00000E+00; -0.00000E+00;  0.00000E+00"));
                            icolumn++;
                        }
                    }
                    sw.WriteLine();
                }
            }
        }
    }

    public static CubeData Load(string cubeFilePath){
        string[] commentLines = new string[2];
        int nAtoms;
        double[] origin = new double[3];
        int[] nVoxels = new int[3];
        double[,] axes = new double[3,3];
        int[] atomicNumbers;
        double[] nuclearCharges;
        double[,] atomPositions;
        List<double[,,]> data;
        bool containDsetIds;
        int nVal;
        List<int> dsetIds;

        // Read cube file
        //try
        //{
        var fileInfo = new System.IO.FileInfo(cubeFilePath);
        string[] line;
        using (var sr = new System.IO.StreamReader(fileInfo.OpenRead(), System.Text.Encoding.UTF8))
        {
            commentLines[0] = sr.ReadLine();
            commentLines[1] = sr.ReadLine();

            line = Regex.Split(sr.ReadLine().Trim(), " +");
            //System.Console.WriteLine(line.Length);
            
            nAtoms = int.Parse(line[0]);
            containDsetIds = nAtoms < 0;
            if (containDsetIds) { nAtoms = -nAtoms; }
            for (int i = 0; i < 3; ++i){
                origin[i] = double.Parse(line[i + 1]);
            }
            
            for (int i = 0; i < 3; ++i){
                line = Regex.Split(sr.ReadLine().Trim(), " +");
                nVoxels[i] = int.Parse(line[0]);
                for (int j = 0; j < 3; ++j){
                    axes[i, j] = double.Parse(line[j + 1]);
                }
            }
            
            atomicNumbers = new int[nAtoms];
            nuclearCharges = new double[nAtoms];
            atomPositions = new double[nAtoms, 3];
            for (int i = 0; i < nAtoms; ++i){
                line = Regex.Split(sr.ReadLine().Trim(), " +");
                atomicNumbers[i] = int.Parse(line[0]);
                nuclearCharges[i] = double.Parse(line[1]);
                for (int j = 0; j < 3; ++j){
                    atomPositions[i, j] = double.Parse(line[j + 2]);
                }
            }

            if(containDsetIds){
                line = Regex.Split(sr.ReadLine().Trim(), " +");
                nVal = int.Parse(line[0]);
                dsetIds = new List<int>();
                int j = 1;
                for (int i = 0; i < nVal; ++i, ++j){
                    if(line.Length == j){
                        line = Regex.Split(sr.ReadLine().Trim(), " +");
                        j = 0;
                    }
                    //dsetIds[i] = int.Parse(line[j]);
                    dsetIds.Add(int.Parse(line[j]));
                }
            }else{
                nVal = 1;
                dsetIds = new List<int> { -1 };
            }

            //data = new double[nVoxels[0], nVoxels[1], nVoxels[2], nVal];
            data = new List<double[,,]>();
            for (int im = 0; im < nVal; ++im){ data.Add(new double[nVoxels[0], nVoxels[1], nVoxels[2]]); }

            line = Regex.Split(sr.ReadLine().Trim(), " +");
            int k = 0;
            for (int ix = 0; ix < nVoxels[0]; ++ix)
            for (int iy = 0; iy < nVoxels[1]; ++iy)
            for (int iz = 0; iz < nVoxels[2]; ++iz){
                for (int im = 0; im < nVal; ++im, ++k){
                    if (line.Length == k){
                        line = Regex.Split(sr.ReadLine().Trim(), " +");
                        k = 0;
                    }
                    //data[ix, iy, iz, im] = double.Parse(line[k]);
                    data[im][ix, iy, iz] = double.Parse(line[k]);
                }
            }
                
        }

        return new CubeData(
            commentLines, nAtoms, origin, nVoxels, axes, 
            atomicNumbers, nuclearCharges, atomPositions, data,
            containDsetIds, nVal, dsetIds);
    }

    public static CubeData LoadNew(string cubeFilePath)
    {
        string[] commentLines = new string[2];
        int nAtoms;
        double[] origin = new double[3];
        int[] nVoxels = new int[3];
        double[,] axes = new double[3, 3];
        int[] atomicNumbers;
        double[] nuclearCharges;
        double[,] atomPositions;
        List<double[,,]> data;
        bool containDsetIds;
        int nVal;
        List<int> dsetIds;

        // Read cube file
        var fileInfo = new System.IO.FileInfo(cubeFilePath);
        string filestring;
        using (var sr = new System.IO.StreamReader(fileInfo.OpenRead(), System.Text.Encoding.UTF8))
        {
            filestring = sr.ReadToEnd();
        }


        string[] line;
        using (var sr = new System.IO.StringReader(filestring))
        {
            commentLines[0] = sr.ReadLine();
            commentLines[1] = sr.ReadLine();

            line = Regex.Split(sr.ReadLine().Trim(), " +");
            //System.Console.WriteLine(line.Length);

            nAtoms = int.Parse(line[0]);
            containDsetIds = nAtoms < 0;
            if (containDsetIds) { nAtoms = -nAtoms; }
            for (int i = 0; i < 3; ++i){
                origin[i] = double.Parse(line[i + 1]);
            }

            for (int i = 0; i < 3; ++i){
                line = Regex.Split(sr.ReadLine().Trim(), " +");
                nVoxels[i] = int.Parse(line[0]);
                for (int j = 0; j < 3; ++j){
                    axes[i, j] = double.Parse(line[j + 1]);
                }
            }

            atomicNumbers = new int[nAtoms];
            nuclearCharges = new double[nAtoms];
            atomPositions = new double[nAtoms, 3];
            for (int i = 0; i < nAtoms; ++i){
                line = Regex.Split(sr.ReadLine().Trim(), " +");
                atomicNumbers[i] = int.Parse(line[0]);
                nuclearCharges[i] = double.Parse(line[1]);
                for (int j = 0; j < 3; ++j){
                    atomPositions[i, j] = double.Parse(line[j + 2]);
                }
            }

            if (containDsetIds){
                line = Regex.Split(sr.ReadLine().Trim(), " +");
                nVal = int.Parse(line[0]);
                dsetIds = new List<int>();
                int j = 1;
                for (int i = 0; i < nVal; ++i, ++j){
                    if (line.Length == j){
                        line = Regex.Split(sr.ReadLine().Trim(), " +");
                        j = 0;
                    }
                    //dsetIds[i] = int.Parse(line[j]);
                    dsetIds.Add(int.Parse(line[j]));
                }
            }
            else{
                nVal = 1;
                dsetIds = new List<int> { -1 };
            }

            //data = new double[nVoxels[0], nVoxels[1], nVoxels[2], nVal];
            data = new List<double[,,]>();
            for (int im = 0; im < nVal; ++im) { data.Add(new double[nVoxels[0], nVoxels[1], nVoxels[2]]); }

            line = Regex.Split(sr.ReadLine().Trim(), " +");
            int k = 0;
            for (int ix = 0; ix < nVoxels[0]; ++ix)
            for (int iy = 0; iy < nVoxels[1]; ++iy)
            for (int iz = 0; iz < nVoxels[2]; ++iz)
            for (int im = 0; im < nVal; ++im, ++k){
                if (line.Length == k){
                    line = Regex.Split(sr.ReadLine().Trim(), " +");
                    k = 0;
                }
                //data[ix, iy, iz, im] = double.Parse(line[k]);
                data[im][ix, iy, iz] = double.Parse(line[k]);
            }
        }


        return new CubeData(
            commentLines, nAtoms, origin, nVoxels, axes,
            atomicNumbers, nuclearCharges, atomPositions, data,
            containDsetIds, nVal, dsetIds);
    }



    public IEnumerable<float> LoadCoroutine(string cubeFilePath, int interval=6000){
        string[] commentLines = new string[2];
        int nAtoms;
        double[] origin = new double[3];
        int[] nVoxels = new int[3];
        double[,] axes = new double[3, 3];
        int[] atomicNumbers;
        double[] nuclearCharges;
        double[,] atomPositions;
        List<double[,,]> data;
        bool containDsetIds;
        int nVal;
        List<int> dsetIds;

        var fileInfo = new System.IO.FileInfo(cubeFilePath);
        string[] line;
        using (var sr = new System.IO.StreamReader(fileInfo.OpenRead(), System.Text.Encoding.UTF8))
        {
            commentLines[0] = sr.ReadLine();
            commentLines[1] = sr.ReadLine();

            line = Regex.Split(sr.ReadLine().Trim(), " +");

            nAtoms = int.Parse(line[0]);
            containDsetIds = nAtoms < 0;
            if (containDsetIds) { nAtoms = -nAtoms; }
            for (int i = 0; i < 3; ++i){
                origin[i] = double.Parse(line[i + 1]);
            }

            for (int i = 0; i < 3; ++i){
                line = Regex.Split(sr.ReadLine().Trim(), " +");
                nVoxels[i] = int.Parse(line[0]);
                for (int j = 0; j < 3; ++j){
                    axes[i, j] = double.Parse(line[j + 1]);
                }
            }

            atomicNumbers = new int[nAtoms];
            nuclearCharges = new double[nAtoms];
            atomPositions = new double[nAtoms, 3];
            for (int i = 0; i < nAtoms; ++i){
                line = Regex.Split(sr.ReadLine().Trim(), " +");
                atomicNumbers[i] = int.Parse(line[0]);
                nuclearCharges[i] = double.Parse(line[1]);
                for (int j = 0; j < 3; ++j){
                    atomPositions[i, j] = double.Parse(line[j + 2]);
                }
            }

            if (containDsetIds){
                line = Regex.Split(sr.ReadLine().Trim(), " +");
                nVal = int.Parse(line[0]);
                dsetIds = new List<int>();
                int j = 1;
                for (int i = 0; i < nVal; ++i, ++j){
                    if (line.Length == j){
                        line = Regex.Split(sr.ReadLine().Trim(), " +");
                        j = 0;
                    }
                    //dsetIds[i] = int.Parse(line[j]);
                    dsetIds.Add(int.Parse(line[j]));
                }
            }
            else{
                nVal = 1;
                dsetIds = new List<int> { -1 };
            }

            yield return 0f;

            int progress = 0;
            int nData = nVoxels[0] * nVoxels[1] * nVoxels[2] * nVal;

            //data = new double[nVoxels[0], nVoxels[1], nVoxels[2], nVal];
            data = new List<double[,,]>();
            for (int im = 0; im < nVal; ++im) { data.Add(new double[nVoxels[0], nVoxels[1], nVoxels[2]]); }

            line = Split(sr.ReadLine().Trim());
            int k = 0;
            for (int ix = 0; ix < nVoxels[0]; ++ix){
            for (int iy = 0; iy < nVoxels[1]; ++iy)
                for (int iz = 0; iz < nVoxels[2]; ++iz)
                for (int im = 0; im < nVal; ++im, ++k){
                    if (line.Length == k){
                        line = Split(sr.ReadLine().Trim());
                        k = 0;
                    }
                    //data[ix, iy, iz, im] = double.Parse(line[k]);
                    data[im][ix, iy, iz] = double.Parse(line[k]);
                    
                    if(++progress%interval==0){
                        yield return (float)progress / (float)nData;
                    }
                }
            }

        }

        CommentLines = commentLines;
        NAtoms = nAtoms;
        Origin = origin;
        NVoxels = nVoxels;
        Axes = axes;
        AtomicNumbers = atomicNumbers;
        NuclearCharges = nuclearCharges;
        AtomPositions = atomPositions;
        Data = data;
        ContainDsetIds = containDsetIds;
        NVal = nVal;
        DsetIds = dsetIds;

        yield return 1f;
    }

    string[] Split(string input){
        var retval = new List<string>();

        int startIndex = -1;
        for (int i = 0; i < input.Length; ++i){
            if (input[i] == ' '){
                if (startIndex != -1){
                    retval.Add(input.Substring(startIndex, i-startIndex));
                    startIndex = -1;
                }
            }else{
                if(startIndex == -1){ startIndex = i; }
            }
        }

        if (startIndex != -1) { retval.Add(input.Substring(startIndex)); }

        return retval.ToArray();
    }

    public static void Main(){
        var cubeData = Load("h2o.cube");
        cubeData.Save("h2o.CSdebug.cube");
    }
}
